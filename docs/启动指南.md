# Parsers gRPC 服务启动指南

本文档提供了 Parsers gRPC 微服务的完整启动指导，包括直接运行和 Docker 部署两种方式。

---

## 📋 目录

- [系统要求](#系统要求)
- [方式一：直接运行（开发/测试）](#方式一直接运行开发测试)
- [方式二：Docker 运行（生产推荐）](#方式二docker-运行生产推荐)
- [环境变量配置](#环境变量配置)
- [健康检查](#健康检查)
- [故障排查](#故障排查)

---

## 系统要求

### 硬件要求
- **CPU**: 最低 4 核，推荐 8 核以上
- **内存**: 最低 2GB，推荐 4GB 以上
- **存储**: ~500MB（OCR 模型）

### 软件要求
- **Python**: 3.11+
- **uv**: 最新版本（包管理工具）
- **Docker**: 20.10+ （可选，仅 Docker 部署需要）
- **Docker Compose**: 2.0+ （可选，仅 Docker 部署需要）

### 依赖库
项目使用 `uv` 管理依赖，所有依赖定义在 `pyproject.toml` 中。

---

## 方式一：直接运行（开发/测试）

### 1. 克隆项目

```bash
# 如果项目已在本地，跳过此步骤
cd /home/wenct/zhengqi/parsers
```

### 2. 安装依赖

```bash
# 创建虚拟环境并安装依赖
uv sync

# 验证安装
uv run python --version
# 应该输出: Python 3.11.x
```

### 3. 生成 gRPC 代码

```bash
# 执行 Proto 代码生成脚本
chmod +x scripts/generate_proto.sh
./scripts/generate_proto.sh

# 验证生成结果
ls -lh grpc_service/generated/
# 应该看到: parser_pb2.py, parser_pb2_grpc.py
```

### 4. 配置环境变量（可选）

```bash
# 复制环境变量模板
cp .env.example .env

# 编辑配置文件（使用你喜欢的编辑器）
nano .env
```

**推荐配置示例**（8 核机器）：
```bash
# gRPC 服务配置
PARSER_GRPC_PORT=50051
PARSER_GRPC_MAX_WORKERS=64
PARSER_GRPC_PRELOAD_OCR=true

# 日志配置
PARSER_LOG_DIR=./logs
PARSER_LOG_LEVEL=INFO

# 页面级进程池配置（页面并发解析）
PARSER_PAGE_POOL_MAX_WORKERS=0        # 0=自动计算
PARSER_PAGE_POOL_RESERVED_CORES=2     # 保留 2 核给 OCR
PARSER_PAGE_POOL_MAX_LIMIT=32         # 最大 32 个进程

# OCR 进程池配置（OCR 引擎进程数）
PARSER_OCR_POOL_MAX_WORKERS=0         # 0=自动计算
PARSER_OCR_POOL_MAX_LIMIT=5           # 最大 5 个 OCR 进程

# OCR 并发配置（任务级并发控制）
PARSER_OCR_MAX_CONCURRENT=10          # 同时处理 10 张图像
PARSER_OCR_TIMEOUT_PER_IMAGE=180.0    # 单图超时 180 秒
```

### 5. 启动服务

#### 方法 A：使用启动脚本（推荐）

```bash
# 启动服务（后台运行）
./scripts/start.sh

# 查看启动日志
tail -f logs/run.out

# 等待看到以下输出表示启动成功：
# 🚀 Parser gRPC 服务已启动，端口: 50051
# 🚀 OCR 引擎预热成功，服务已就绪
```

**启动脚本特性**：
- ✅ 后台运行（nohup），不依赖终端
- ✅ PID 文件管理，防止重复启动
- ✅ 自动验证模块导入
- ✅ 完整的日志输出

#### 方法 B：前台启动（调试模式）

```bash
# 设置 PYTHONPATH（必须）
export PYTHONPATH=/home/wenct/zhengqi:$PYTHONPATH

# 启动服务
uv run python -m parsers.grpc_service.server

# 输出会直接显示在终端
# Ctrl+C 停止服务
```

### 6. 停止服务

```bash
# 使用停止脚本（推荐）
./scripts/stop.sh

# 或者手动终止进程
kill -TERM $(cat logs/server.pid)
```

**停止脚本特性**：
- ✅ 优雅关闭（SIGTERM），等待当前请求完成
- ✅ 进程组管理，清理所有子进程
- ✅ 超时保护（30 秒），自动强制终止

### 7. 验证服务

```bash
# 使用 Python 客户端测试
uv run python -c "
from parsers.grpc_service.client import ParserGrpcClient

# 健康检查
client = ParserGrpcClient()
is_healthy = client.health_check()
print('服务状态:', '✅ 正常' if is_healthy else '❌ 异常')
client.close()
"
```

---

## 方式二：Docker 运行（生产推荐）

### 1. 准备 Docker 环境

```bash
# 确认 Docker 已安装
docker --version
docker-compose --version

# 确保 Docker 服务运行中
sudo systemctl status docker
```

### 2. 配置环境变量（可选）

```bash
# 创建 .env 文件
cp .env.example .env

# 编辑 Docker 特定配置
nano .env
```

**Docker 推荐配置**：
```bash
# gRPC 服务配置
PARSER_GRPC_PORT=50051
PARSER_GRPC_MAX_WORKERS=64
PARSER_GRPC_PRELOAD_OCR=true

# 页面级进程池配置
PARSER_PAGE_POOL_MAX_WORKERS=0
PARSER_PAGE_POOL_RESERVED_CORES=2
PARSER_PAGE_POOL_MAX_LIMIT=32          # Docker 容器现在可以使用主机所有核心

# OCR 进程池配置
PARSER_OCR_POOL_MAX_WORKERS=0
PARSER_OCR_POOL_MAX_LIMIT=5            # 与本地配置一致

# OCR 并发配置
PARSER_OCR_MAX_CONCURRENT=10           # 与本地配置一致
PARSER_OCR_TIMEOUT_PER_IMAGE=180.0
```

### 3. 构建镜像

```bash
# 构建 Docker 镜像
docker-compose build

# 查看镜像
docker images | grep parsers-grpc
```

### 4. 启动服务

#### 单副本启动

```bash
# 启动服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f parser-service
```

#### 多副本启动（负载均衡）

```bash
# 启动 3 个副本
docker-compose up -d --scale parser-service=3

# 查看所有副本
docker-compose ps

# 查看特定副本日志
docker logs -f <container_id>
```

### 5. 健康检查

```bash
# 方法 1：使用 Docker 健康检查
docker-compose ps
# 查看 STATUS 列，应该显示 "healthy"

# 方法 2：手动执行健康检查脚本
docker exec <container_id> /bin/bash /app/parsers/scripts/grpc_health_check.sh

# 方法 3：从宿主机测试
uv run python -c "
from parsers.grpc_service.client import ParserGrpcClient
client = ParserGrpcClient(host='localhost', port=50051)
print('服务状态:', '✅ 正常' if client.health_check() else '❌ 异常')
client.close()
"
```

### 6. 停止服务

```bash
# 停止服务（保留容器）
docker-compose stop

# 停止并删除容器
docker-compose down

# 停止并删除容器、网络、卷
docker-compose down -v
```

### 7. 重启服务

```bash
# 重启服务（不重新构建）
docker-compose restart

# 重新构建并启动
docker-compose up -d --build
```

---

## 环境变量配置

### 核心配置说明

| 环境变量 | 默认值 | 说明 | 推荐值 |
|---------|-------|------|-------|
| **gRPC 服务配置** |
| `PARSER_GRPC_PORT` | `50051` | gRPC 服务端口 | `50051` |
| `PARSER_GRPC_MAX_WORKERS` | `10` | gRPC 线程池大小 | `64` |
| `PARSER_GRPC_PRELOAD_OCR` | `true` | 是否预加载 OCR 引擎 | `true` |
| **页面级进程池配置** |
| `PARSER_PAGE_POOL_MAX_WORKERS` | `0` | 页面进程数（0=自动） | `0` |
| `PARSER_PAGE_POOL_RESERVED_CORES` | `2` | 保留核心数 | `2` |
| `PARSER_PAGE_POOL_MAX_LIMIT` | `32` | 页面进程数上限 | `32`（本地）/ `16`（Docker） |
| **OCR 进程池配置** |
| `PARSER_OCR_POOL_MAX_WORKERS` | `0` | OCR 进程数（0=自动） | `0` |
| `PARSER_OCR_POOL_MAX_LIMIT` | `5` | OCR 进程数上限 | `5`（本地）/ `4`（Docker） |
| **OCR 并发配置** |
| `PARSER_OCR_MAX_CONCURRENT` | `10` | 同时处理的图像数 | `10`（本地）/ `8`（Docker） |
| `PARSER_OCR_TIMEOUT_PER_IMAGE` | `180.0` | 单图超时（秒） | `180.0` |
| **日志配置** |
| `PARSER_LOG_DIR` | `./logs` | 日志目录 | `./logs` |
| `PARSER_LOG_LEVEL` | `INFO` | 日志级别 | `INFO` |

### 核心占用计算

**公式**：
```
页面进程数 = min(cpu_count - reserved_cores, page_max_limit)
OCR 进程数 = min(cpu_count, ocr_max_limit)
总进程数 = 页面进程数 + OCR 进程数
```

**示例**（8 核机器，默认配置）：
```
页面进程数 = min(8 - 2, 32) = 6
OCR 进程数 = min(8, 5) = 5
总进程数 = 6 + 5 = 11 个进程
```

### 不同机器的推荐配置

#### 小型机器（4 核）
```bash
PARSER_PAGE_POOL_MAX_LIMIT=8
PARSER_OCR_POOL_MAX_LIMIT=3
PARSER_OCR_MAX_CONCURRENT=6

# 总进程数: min(4-2, 8) + min(4, 3) = 2 + 3 = 5
```

#### 中型机器（8 核）
```bash
PARSER_PAGE_POOL_MAX_LIMIT=16
PARSER_OCR_POOL_MAX_LIMIT=5
PARSER_OCR_MAX_CONCURRENT=10

# 总进程数: min(8-2, 16) + min(8, 5) = 6 + 5 = 11
```

#### 大型机器（16+ 核）
```bash
PARSER_PAGE_POOL_MAX_LIMIT=32
PARSER_OCR_POOL_MAX_LIMIT=8
PARSER_OCR_MAX_CONCURRENT=16

# 总进程数: min(16-2, 32) + min(16, 8) = 14 + 8 = 22
```

---

## 健康检查

### 检查方式

#### 1. gRPC 健康检查（推荐）

```bash
# 使用客户端库
uv run python -c "
from parsers.grpc_service.client import ParserGrpcClient
client = ParserGrpcClient(host='localhost', port=50051)
result = client.health_check()
print('✅ 服务正常' if result else '❌ 服务异常')
client.close()
"
```

#### 2. 端口检查

```bash
# 检查端口是否监听
lsof -i :50051

# 或者使用 netstat
netstat -tuln | grep 50051
```

#### 3. 进程检查

```bash
# 查看 gRPC 服务进程
ps aux | grep "parsers.grpc_service.server"

# 查看子进程
pstree -p $(cat logs/server.pid)
```

#### 4. 日志检查

```bash
# 查看最新日志
tail -n 50 logs/run.out

# 实时监控日志
tail -f logs/run.out

# 搜索错误
grep -i error logs/run.out
```

### 健康状态判断

**正常状态指标**：
- ✅ gRPC 健康检查返回 `SERVING`
- ✅ 端口 50051 正在监听
- ✅ 日志中显示 "🚀 Parser gRPC 服务已启动"
- ✅ 日志中显示 "🚀 OCR 引擎预热成功"

**异常状态指标**：
- ❌ gRPC 健康检查失败或超时
- ❌ 端口未监听
- ❌ 日志中有 ERROR 或 CRITICAL 级别消息
- ❌ 进程不存在或僵死

---

## 故障排查

### 问题 1：服务启动失败

**症状**：执行 `./scripts/start.sh` 后无输出或立即退出

**排查步骤**：
```bash
# 1. 查看启动日志
cat logs/run.out

# 2. 检查 Python 模块导入
PYTHONPATH=/home/wenct/zhengqi:$PYTHONPATH uv run python -c "from parsers.grpc_service import server"

# 3. 检查依赖是否安装
uv sync --frozen

# 4. 检查 gRPC 代码是否生成
ls -lh grpc_service/generated/
```

**常见原因**：
- PYTHONPATH 未设置
- 依赖未安装
- Proto 代码未生成
- 端口被占用

### 问题 2：端口被占用

**症状**：日志显示 "failed to bind"

**解决方案**：
```bash
# 1. 查找占用端口的进程
lsof -i :50051

# 2. 终止进程
kill -9 <PID>

# 3. 或者修改端口
export PARSER_GRPC_PORT=50052
./scripts/start.sh
```

### 问题 3：OCR 模型下载失败

**症状**：启动时卡住，日志显示 "加载 OCR 模型..."

**解决方案**：
```bash
# 1. 手动下载模型
uv run python -c "from parsers.ocr_engine import get_ocr_engine; get_ocr_engine()"

# 2. 检查网络连接
ping www.baidu.com

# 3. 设置代理（如果需要）
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080

# 4. 检查模型目录
ls -lh ~/.paddleocr/
```

### 问题 4：内存不足

**症状**：服务启动后崩溃，日志显示 "MemoryError" 或 "killed"

**解决方案**：
```bash
# 1. 减少进程数
export PARSER_PAGE_POOL_MAX_LIMIT=8
export PARSER_OCR_POOL_MAX_LIMIT=3

# 2. 重启服务
./scripts/stop.sh
./scripts/start.sh

# 3. 检查内存使用
free -h
```

### 问题 5：Docker 容器健康检查失败

**症状**：`docker-compose ps` 显示 "unhealthy"

**排查步骤**：
```bash
# 1. 查看容器日志
docker-compose logs parser-service

# 2. 进入容器检查
docker exec -it <container_id> /bin/bash

# 3. 手动执行健康检查
./scripts/grpc_health_check.sh

# 4. 检查 OCR 模型
ls -lh ~/.paddleocr/
```

### 问题 6：解析性能慢

**症状**：处理文档耗时过长

**优化建议**：
```bash
# 1. 增加进程数（如果有足够核心和内存）
export PARSER_PAGE_POOL_MAX_LIMIT=32
export PARSER_OCR_POOL_MAX_LIMIT=8
export PARSER_OCR_MAX_CONCURRENT=16

# 2. 检查 CPU 使用率
top -p $(cat logs/server.pid)

# 3. 检查是否启用了 AVX 指令集
uv run python -c "
import numpy as np
print('AVX 支持:', hasattr(np.core._multiarray_umath, '__cpu_features__'))
"

# 4. 查看并发统计
grep "解析完成" logs/run.out | tail -n 10
```

---

## 附录：快速参考

### 常用命令

```bash
# 启动服务
./scripts/start.sh

# 停止服务
./scripts/stop.sh

# 重启服务
./scripts/stop.sh && ./scripts/start.sh

# 查看日志
tail -f logs/run.out

# 健康检查
./scripts/grpc_health_check.sh

# 生成 Proto 代码
./scripts/generate_proto.sh
```

### Docker 常用命令

```bash
# 构建镜像
docker-compose build

# 启动服务
docker-compose up -d

# 停止服务
docker-compose down

# 查看日志
docker-compose logs -f parser-service

# 重启服务
docker-compose restart

# 多副本启动
docker-compose up -d --scale parser-service=3
```

### 测试命令

```bash
# Python 客户端测试
uv run python -c "
from parsers.grpc_service.client import ParserGrpcClient

with ParserGrpcClient() as client:
    # 读取本地文件
    with open('/path/to/test.pdf', 'rb') as f:
        content = f.read()

    # 解析文件
    result = client.parse_bytes(content, 'test.pdf')
    print(f'解析成功: {len(result[\"content\"])} 字符')
    print(f'页数: {result[\"metadata\"][\"page_count\"]}')
    print(f'耗时: {result[\"metadata\"][\"parse_time_ms\"]} ms')
"
```

---

## 技术支持

如果遇到本文档未涵盖的问题，请：

1. 查看项目根目录的 `README.md` 和 `CLAUDE.md`
2. 查看 `logs/` 目录下的完整日志
3. 在项目仓库提交 Issue（如果有）
4. 联系项目维护者

**最后更新**：2025-01-11
