# Parsers gRPC å¾®æœåŠ¡è°ƒç”¨æ–¹ä½¿ç”¨æŒ‡å—

æœ¬æ–‡æ¡£ä¸ºå¤–éƒ¨ç³»ç»Ÿï¼ˆè°ƒç”¨æ–¹ï¼‰æä¾›å®Œæ•´çš„ä½¿ç”¨æŒ‡å¯¼ï¼ŒåŒ…æ‹¬å¿«é€Ÿå¼€å§‹ã€API è¯´æ˜ã€å¤šè¯­è¨€ç¤ºä¾‹ã€éƒ¨ç½²é…ç½®ã€é”™è¯¯å¤„ç†å’Œæœ€ä½³å®è·µã€‚

## API åè®®è¯´æ˜

### Proto æ–‡ä»¶å®Œæ•´å®šä¹‰

```protobuf
syntax = "proto3";

package parser;

// è§£æå™¨æœåŠ¡å®šä¹‰
service ParserService {
  // è§£ææ–‡ä»¶ï¼ˆä¸»è¦æ¥å£ï¼‰
  rpc ParseFile(ParseRequest) returns (ParseResponse);

  // å¥åº·æ£€æŸ¥ï¼ˆKubernetes å‹å¥½ï¼‰
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

// è§£æè¯·æ±‚æ¶ˆæ¯
message ParseRequest {
  bytes file_content = 1;            // æ–‡ä»¶äºŒè¿›åˆ¶å†…å®¹
  string file_name = 2;              // æ–‡ä»¶åï¼ˆç”¨äºæ ¼å¼æ£€æµ‹ï¼Œå¦‚ "report.pdf"ï¼‰
  ParseOptions options = 3;          // è§£æé€‰é¡¹
}

message ParseOptions {
  bool enable_ocr = 1;               // æ˜¯å¦å¯ç”¨ OCRï¼ˆé»˜è®¤ trueï¼‰
  bool enable_caption = 2;           // æ˜¯å¦å¯ç”¨ VLM Captionï¼ˆé»˜è®¤ falseï¼‰
  int32 max_image_size = 3;          // æœ€å¤§å›¾åƒå°ºå¯¸ï¼ˆé»˜è®¤ 4096pxï¼‰
  string language = 4;               // OCR è¯­è¨€ï¼ˆé»˜è®¤ "ch"ï¼‰
}

// è§£æå“åº”æ¶ˆæ¯
message ParseResponse {
  string content = 1;                // è§£æåçš„æ–‡æœ¬å†…å®¹
  ParseMetadata metadata = 2;        // å…ƒæ•°æ®
  string error_message = 3;          // é”™è¯¯æ¶ˆæ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
}

message ParseMetadata {
  int32 page_count = 1;              // é¡µæ•°ï¼ˆPDF/PPTXï¼‰
  int32 image_count = 2;             // å›¾åƒæ•°é‡
  int32 table_count = 3;             // è¡¨æ ¼æ•°é‡
  int32 ocr_count = 4;               // OCR è¯†åˆ«çš„å›¾åƒæ•°é‡
  int32 caption_count = 5;           // Caption ç”Ÿæˆçš„å›¾åƒæ•°é‡
  float parse_time_ms = 6;           // è§£æè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
}

// å¥åº·æ£€æŸ¥è¯·æ±‚
message HealthCheckRequest {
  string service = 1;
}

// å¥åº·æ£€æŸ¥å“åº”
message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
    SERVICE_UNKNOWN = 3;
  }
  ServingStatus status = 1;
}
```

### æ¥å£è¯´æ˜

#### ParseFile - æ–‡ä»¶è§£ææ¥å£

**åŠŸèƒ½**ï¼šå°†ä¸Šä¼ çš„æ–‡æ¡£ï¼ˆPDFã€DOCXã€PPTXã€Markdownï¼‰è§£æä¸ºç»“æ„åŒ–æ–‡æœ¬ã€‚

**è¯·æ±‚å‚æ•°**ï¼š

| å­—æ®µ | ç±»å‹ | å¿…å¡« | è¯´æ˜ |
|------|------|------|------|
| `file_content` | bytes | âœ… æ˜¯ | æ–‡ä»¶äºŒè¿›åˆ¶å†…å®¹ï¼ˆç›´æ¥ä¸Šä¼ ï¼Œæ— éœ€æ–‡ä»¶è·¯å¾„ï¼‰ |
| `file_name` | string | âœ… æ˜¯ | æ–‡ä»¶åï¼ˆç”¨äºæ ¼å¼æ£€æµ‹ï¼Œå¦‚ "report.pdf"ï¼‰ |
| `options.enable_ocr` | bool | âŒ å¦ | æ˜¯å¦å¯ç”¨ OCRï¼Œé»˜è®¤ true |
| `options.max_image_size` | int32 | âŒ å¦ | å›¾åƒæœ€å¤§å°ºå¯¸ï¼ˆåƒç´ ï¼‰ï¼Œé»˜è®¤ 4096 |

**å“åº”å­—æ®µ**ï¼š

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `content` | string | è§£æåçš„æ–‡æœ¬å†…å®¹ï¼ˆMarkdown æ ¼å¼ï¼‰ |
| `metadata.page_count` | int32 | æ–‡æ¡£é¡µæ•°ï¼ˆPDF/PPTXï¼‰ |
| `metadata.image_count` | int32 | å›¾åƒæ€»æ•° |
| `metadata.table_count` | int32 | è¡¨æ ¼æ€»æ•° |
| `metadata.ocr_count` | int32 | OCR è¯†åˆ«çš„å›¾åƒæ•°é‡ |
| `metadata.caption_count` | int32 | Caption ç”Ÿæˆçš„å›¾åƒæ•°é‡(é¢„ç•™VLMæ¨¡å‹) |
| `metadata.parse_time_ms` | float | è§£æè€—æ—¶ï¼ˆæ¯«ç§’ï¼‰ |
| `error_message` | string | é”™è¯¯æ¶ˆæ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰ |

**æ”¯æŒçš„æ–‡ä»¶æ ¼å¼**ï¼š
- âœ… PDFï¼ˆ`.pdf`ï¼‰
- âœ… DOCXï¼ˆ`.docx`ï¼‰
- âœ… PPTXï¼ˆ`.pptx`ï¼‰
- âœ… Markdownï¼ˆ`.md`ã€`.markdown`ï¼‰

**æ–‡ä»¶å¤§å°é™åˆ¶**ï¼š
- é»˜è®¤æœ€å¤§ 50MBï¼ˆç”± gRPC é…ç½® `grpc.max_send_message_length` æ§åˆ¶ï¼‰
- å»ºè®®å•æ–‡ä»¶ä¸è¶…è¿‡ 50MBï¼Œè¶…å¤§æ–‡ä»¶éœ€è¦è°ƒæ•´æœåŠ¡ç«¯é…ç½®

**è¶…æ—¶æ—¶é—´**ï¼š
- é»˜è®¤ 300 ç§’ï¼ˆ5 åˆ†é’Ÿï¼‰
- å¤æ‚æ–‡æ¡£ï¼ˆæ‰«æç‰ˆ PDFã€å¤§é‡å›¾åƒï¼‰å¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´

#### HealthCheck - å¥åº·æ£€æŸ¥æ¥å£

**åŠŸèƒ½**ï¼šæ£€æŸ¥æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œï¼ˆKubernetes liveness/readiness probeï¼‰ã€‚

**è¯·æ±‚å‚æ•°**ï¼š

| å­—æ®µ | ç±»å‹ | å¿…å¡« | è¯´æ˜ |
|------|------|------|------|
| `service` | string | âŒ å¦ | æœåŠ¡åç§°ï¼Œé»˜è®¤ "parser.ParserService" |

**å“åº”å­—æ®µ**ï¼š

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `status` | ServingStatus | æœåŠ¡çŠ¶æ€ï¼ˆSERVING/NOT_SERVING/UNKNOWNï¼‰ |

**ServingStatus æšä¸¾å€¼**ï¼š
- `SERVING (1)`: æœåŠ¡æ­£å¸¸è¿è¡Œ
- `NOT_SERVING (2)`: æœåŠ¡ä¸å¯ç”¨
- `UNKNOWN (0)`: æœªçŸ¥çŠ¶æ€
- `SERVICE_UNKNOWN (3)`: æœåŠ¡æœªçŸ¥

---

## Python å®¢æˆ·ç«¯å®Œæ•´æŒ‡å—

### æ–¹å¼ 1ï¼šä½¿ç”¨å®˜æ–¹å°è£…å®¢æˆ·ç«¯ï¼ˆæ¨èï¼‰

å¦‚æœä½ çš„é¡¹ç›®å¯ä»¥å¼•å…¥ Parsers é¡¹ç›®çš„ `grpc/client.py`ï¼Œè¿™æ˜¯æœ€ç®€å•çš„æ–¹å¼ã€‚

#### å®‰è£…ä¾èµ–

```bash
pip install grpcio grpcio-tools python-dotenv
```

#### å¤åˆ¶å®¢æˆ·ç«¯ä»£ç 

ä» Parsers é¡¹ç›®å¤åˆ¶ä»¥ä¸‹æ–‡ä»¶åˆ°ä½ çš„é¡¹ç›®ï¼š

```
your-project/
â”œâ”€â”€ parsers/
â”‚   â””â”€â”€ grpc/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ client.py                # â† å®˜æ–¹å®¢æˆ·ç«¯å°è£…
â”‚       â”œâ”€â”€ generated/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ parser_pb2.py        # â† ä» proto ç”Ÿæˆ
â”‚       â”‚   â””â”€â”€ parser_pb2_grpc.py   # â† ä» proto ç”Ÿæˆ
â”‚       â””â”€â”€ protos/
â”‚           â””â”€â”€ parser.proto
```

#### åŸºæœ¬ç”¨æ³•

**åœºæ™¯ 1ï¼šçŸ­æœŸè¿æ¥ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼‰**

```python
from parsers.grpc.client import ParserGrpcClient

# ä½¿ç”¨ with è¯­å¥è‡ªåŠ¨ç®¡ç†è¿æ¥
with ParserGrpcClient(host="localhost", port=50051) as client:
    # è¯»å–æœ¬åœ°æ–‡ä»¶
    with open("report.pdf", "rb") as f:
        file_content = f.read()

    # è§£ææ–‡ä»¶
    result = client.parse_bytes(
        file_content=file_content,
        file_name="report.pdf",
        enable_ocr=True,
        language="ch"
    )

    # ä½¿ç”¨è§£æç»“æœ
    print(f"è§£ææˆåŠŸï¼å†…å®¹é•¿åº¦: {len(result['content'])} å­—ç¬¦")
    print(f"é¡µæ•°: {result['metadata']['page_count']}")
```

**åœºæ™¯ 2ï¼šé•¿æœŸè¿æ¥ï¼ˆFastAPI ç­‰ Web æ¡†æ¶ï¼‰**

```python
from parsers.grpc.client import get_grpc_client

# ä½¿ç”¨å…¨å±€å•ä¾‹å®¢æˆ·ç«¯ï¼ˆè¿æ¥å¤ç”¨ï¼‰
client = get_grpc_client()

# å¤šæ¬¡è°ƒç”¨ï¼Œå¤ç”¨è¿æ¥
result1 = client.parse_bytes(content1, "file1.pdf")
result2 = client.parse_bytes(content2, "file2.docx")
result3 = client.parse_bytes(content3, "file3.pptx")
```

**åœºæ™¯ 3ï¼šFastAPI é›†æˆç¤ºä¾‹**

```python
from fastapi import FastAPI, UploadFile, File
from parsers.grpc.client import get_grpc_client
import logging

app = FastAPI()
logger = logging.getLogger(__name__)

@app.post("/api/parse")
async def parse_document(file: UploadFile = File(...)):
    """è§£æä¸Šä¼ çš„æ–‡æ¡£"""
    try:
        # è¯»å–ä¸Šä¼ çš„æ–‡ä»¶å†…å®¹
        file_content = await file.read()

        # è°ƒç”¨ gRPC æœåŠ¡
        client = get_grpc_client()
        result = client.parse_bytes(
            file_content=file_content,
            file_name=file.filename,
            enable_ocr=True
        )

        return {
            "status": "success",
            "content": result["content"],
            "metadata": result["metadata"]
        }

    except Exception as e:
        logger.error(f"è§£æå¤±è´¥: {e}")
        return {
            "status": "error",
            "message": str(e)
        }

@app.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥"""
    client = get_grpc_client()
    is_healthy = client.health_check()

    return {
        "status": "healthy" if is_healthy else "unhealthy",
        "service": "parsers-grpc"
    }
```

#### ç¯å¢ƒå˜é‡é…ç½®

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.env` æ–‡ä»¶ï¼š

```bash
# gRPC æœåŠ¡ç«¯é…ç½®
PARSER_GRPC_HOST=localhost
PARSER_GRPC_PORT=50051
PARSER_GRPC_TIMEOUT=300.0
PARSER_GRPC_MAX_RETRIES=3
```

### æ–¹å¼ 2ï¼šè‡ªè¡Œå®ç°å®¢æˆ·ç«¯

å¦‚æœä¸æƒ³å¼•å…¥ Parsers é¡¹ç›®çš„ä»£ç ï¼Œå¯ä»¥è‡ªè¡Œå®ç°å®¢æˆ·ç«¯ã€‚

#### ç”Ÿæˆ gRPC ä»£ç 

```bash
# å®‰è£…å·¥å…·
pip install grpcio grpcio-tools

# ä» proto ç”Ÿæˆ Python ä»£ç 
python -m grpc_tools.protoc \
  -I./protos \
  --python_out=./generated \
  --grpc_python_out=./generated \
  ./protos/parser.proto
```

#### è‡ªå®šä¹‰å®¢æˆ·ç«¯å®ç°

```python
import grpc
from generated import parser_pb2, parser_pb2_grpc

class MyParserClient:
    """è‡ªå®šä¹‰ Parser å®¢æˆ·ç«¯"""

    def __init__(self, host="localhost", port=50051):
        self.address = f"{host}:{port}"
        self.channel = grpc.insecure_channel(
            self.address,
            options=[
                ('grpc.max_send_message_length', 50 * 1024 * 1024),  # 50MB
                ('grpc.max_receive_message_length', 50 * 1024 * 1024),
            ]
        )
        self.stub = parser_pb2_grpc.ParserServiceStub(self.channel)

    def parse_file(self, file_path: str, enable_ocr=True):
        """è§£ææœ¬åœ°æ–‡ä»¶"""
        # è¯»å–æ–‡ä»¶
        with open(file_path, 'rb') as f:
            file_content = f.read()

        # æ„é€ è¯·æ±‚
        request = parser_pb2.ParseRequest(
            file_content=file_content,
            file_name=file_path.split('/')[-1],
            options=parser_pb2.ParseOptions(
                enable_ocr=enable_ocr,
                enable_caption=False,
                max_image_size=4096,
                language="ch"
            )
        )

        # è°ƒç”¨ RPC
        response = self.stub.ParseFile(request, timeout=300)

        # æ£€æŸ¥é”™è¯¯
        if response.error_message:
            raise RuntimeError(response.error_message)

        # è¿”å›ç»“æœ
        return {
            "content": response.content,
            "metadata": {
                "page_count": response.metadata.page_count,
                "image_count": response.metadata.image_count,
                "table_count": response.metadata.table_count,
                "parse_time_ms": response.metadata.parse_time_ms
            }
        }

    def health_check(self):
        """å¥åº·æ£€æŸ¥"""
        request = parser_pb2.HealthCheckRequest(service="parser.ParserService")
        response = self.stub.HealthCheck(request, timeout=5)
        return response.status == parser_pb2.HealthCheckResponse.SERVING

    def close(self):
        """å…³é—­è¿æ¥"""
        self.channel.close()

# ä½¿ç”¨ç¤ºä¾‹
client = MyParserClient(host="localhost", port=50051)

try:
    result = client.parse_file("report.pdf")
    print(f"è§£ææˆåŠŸ: {len(result['content'])} å­—ç¬¦")
finally:
    client.close()
```

---

## å…¶ä»–è¯­è¨€å®¢æˆ·ç«¯ç¤ºä¾‹

### Go å®¢æˆ·ç«¯

#### ç”Ÿæˆ Go ä»£ç 

```bash
# å®‰è£… protoc-gen-go
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

# ç”Ÿæˆ Go ä»£ç 
protoc --go_out=. --go_opt=paths=source_relative \
  --go-grpc_out=. --go-grpc_opt=paths=source_relative \
  protos/parser.proto
```

#### Go å®¢æˆ·ç«¯å®ç°

```go
package main

import (
    "context"
    "io/ioutil"
    "log"
    "time"

    pb "your-project/generated"
    "google.golang.org/grpc"
)

type ParserClient struct {
    conn *grpc.ClientConn
    stub pb.ParserServiceClient
}

func NewParserClient(address string) (*ParserClient, error) {
    conn, err := grpc.Dial(address, grpc.WithInsecure(),
        grpc.WithDefaultCallOptions(
            grpc.MaxCallRecvMsgSize(50*1024*1024),
            grpc.MaxCallSendMsgSize(50*1024*1024),
        ))
    if err != nil {
        return nil, err
    }

    return &ParserClient{
        conn: conn,
        stub: pb.NewParserServiceClient(conn),
    }, nil
}

func (c *ParserClient) ParseFile(filePath string) (*pb.ParseResponse, error) {
    // è¯»å–æ–‡ä»¶
    fileContent, err := ioutil.ReadFile(filePath)
    if err != nil {
        return nil, err
    }

    // æ„é€ è¯·æ±‚
    request := &pb.ParseRequest{
        FileContent: fileContent,
        FileName:    filePath,
        Options: &pb.ParseOptions{
            EnableOcr:     true,
            EnableCaption: false,
            MaxImageSize:  4096,
            Language:      "ch",
        },
    }

    // è°ƒç”¨ RPCï¼ˆ5 åˆ†é’Ÿè¶…æ—¶ï¼‰
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
    defer cancel()

    response, err := c.stub.ParseFile(ctx, request)
    if err != nil {
        return nil, err
    }

    if response.ErrorMessage != "" {
        return nil, fmt.Errorf("parse error: %s", response.ErrorMessage)
    }

    return response, nil
}

func (c *ParserClient) HealthCheck() (bool, error) {
    request := &pb.HealthCheckRequest{Service: "parser.ParserService"}

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    response, err := c.stub.HealthCheck(ctx, request)
    if err != nil {
        return false, err
    }

    return response.Status == pb.HealthCheckResponse_SERVING, nil
}

func (c *ParserClient) Close() {
    c.conn.Close()
}

// ä½¿ç”¨ç¤ºä¾‹
func main() {
    client, err := NewParserClient("localhost:50051")
    if err != nil {
        log.Fatalf("è¿æ¥å¤±è´¥: %v", err)
    }
    defer client.Close()

    // è§£ææ–‡ä»¶
    result, err := client.ParseFile("report.pdf")
    if err != nil {
        log.Fatalf("è§£æå¤±è´¥: %v", err)
    }

    log.Printf("è§£ææˆåŠŸ: %d å­—ç¬¦", len(result.Content))
    log.Printf("é¡µæ•°: %d", result.Metadata.PageCount)
}
```

### Java å®¢æˆ·ç«¯

#### Maven ä¾èµ–

```xml
<dependencies>
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-netty-shaded</artifactId>
        <version>1.60.0</version>
    </dependency>
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-protobuf</artifactId>
        <version>1.60.0</version>
    </dependency>
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-stub</artifactId>
        <version>1.60.0</version>
    </dependency>
</dependencies>

<build>
    <extensions>
        <extension>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.7.0</version>
        </extension>
    </extensions>
    <plugins>
        <plugin>
            <groupId>org.xolstice.maven.plugins</groupId>
            <artifactId>protobuf-maven-plugin</artifactId>
            <version>0.6.1</version>
            <configuration>
                <protocArtifact>com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier}</protocArtifact>
                <pluginId>grpc-java</pluginId>
                <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.60.0:exe:${os.detected.classifier}</pluginArtifact>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>compile</goal>
                        <goal>compile-custom</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

#### Java å®¢æˆ·ç«¯å®ç°

```java
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

public class ParserClient {
    private final ManagedChannel channel;
    private final ParserServiceGrpc.ParserServiceBlockingStub blockingStub;

    public ParserClient(String host, int port) {
        this.channel = ManagedChannelBuilder.forAddress(host, port)
                .usePlaintext()
                .maxInboundMessageSize(50 * 1024 * 1024)  // 50MB
                .build();
        this.blockingStub = ParserServiceGrpc.newBlockingStub(channel);
    }

    public ParseResponse parseFile(String filePath) throws IOException {
        // è¯»å–æ–‡ä»¶
        byte[] fileContent = Files.readAllBytes(Paths.get(filePath));

        // æ„é€ è¯·æ±‚
        ParseRequest request = ParseRequest.newBuilder()
                .setFileContent(com.google.protobuf.ByteString.copyFrom(fileContent))
                .setFileName(Paths.get(filePath).getFileName().toString())
                .setOptions(ParseOptions.newBuilder()
                        .setEnableOcr(true)
                        .setEnableCaption(false)
                        .setMaxImageSize(4096)
                        .setLanguage("ch")
                        .build())
                .build();

        // è°ƒç”¨ RPCï¼ˆ5 åˆ†é’Ÿè¶…æ—¶ï¼‰
        ParseResponse response;
        try {
            response = blockingStub.withDeadlineAfter(5, TimeUnit.MINUTES)
                    .parseFile(request);
        } catch (StatusRuntimeException e) {
            throw new RuntimeException("gRPC è°ƒç”¨å¤±è´¥: " + e.getStatus(), e);
        }

        if (!response.getErrorMessage().isEmpty()) {
            throw new RuntimeException("è§£æå¤±è´¥: " + response.getErrorMessage());
        }

        return response;
    }

    public boolean healthCheck() {
        HealthCheckRequest request = HealthCheckRequest.newBuilder()
                .setService("parser.ParserService")
                .build();

        try {
            HealthCheckResponse response = blockingStub
                    .withDeadlineAfter(5, TimeUnit.SECONDS)
                    .healthCheck(request);
            return response.getStatus() == HealthCheckResponse.ServingStatus.SERVING;
        } catch (StatusRuntimeException e) {
            return false;
        }
    }

    public void shutdown() throws InterruptedException {
        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
    }

    public static void main(String[] args) throws Exception {
        ParserClient client = new ParserClient("localhost", 50051);

        try {
            ParseResponse result = client.parseFile("report.pdf");
            System.out.println("è§£ææˆåŠŸ: " + result.getContent().length() + " å­—ç¬¦");
            System.out.println("é¡µæ•°: " + result.getMetadata().getPageCount());
        } finally {
            client.shutdown();
        }
    }
}
```

### Node.js å®¢æˆ·ç«¯

#### å®‰è£…ä¾èµ–

```bash
npm install @grpc/grpc-js @grpc/proto-loader
```

#### Node.js å®¢æˆ·ç«¯å®ç°

```javascript
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const fs = require('fs');

// åŠ è½½ proto æ–‡ä»¶
const packageDefinition = protoLoader.loadSync(
  './protos/parser.proto',
  {
    keepCase: true,
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true
  }
);

const parserProto = grpc.loadPackageDefinition(packageDefinition).parser;

class ParserClient {
  constructor(host = 'localhost', port = 50051) {
    this.client = new parserProto.ParserService(
      `${host}:${port}`,
      grpc.credentials.createInsecure(),
      {
        'grpc.max_send_message_length': 50 * 1024 * 1024,  // 50MB
        'grpc.max_receive_message_length': 50 * 1024 * 1024
      }
    );
  }

  parseFile(filePath, enableOcr = true) {
    return new Promise((resolve, reject) => {
      // è¯»å–æ–‡ä»¶
      const fileContent = fs.readFileSync(filePath);

      // æ„é€ è¯·æ±‚
      const request = {
        file_content: fileContent,
        file_name: filePath.split('/').pop(),
        options: {
          enable_ocr: enableOcr,
          enable_caption: false,
          max_image_size: 4096,
          language: 'ch'
        }
      };

      // è°ƒç”¨ RPCï¼ˆ5 åˆ†é’Ÿè¶…æ—¶ï¼‰
      const deadline = new Date();
      deadline.setSeconds(deadline.getSeconds() + 300);

      this.client.ParseFile(request, { deadline }, (error, response) => {
        if (error) {
          reject(error);
          return;
        }

        if (response.error_message) {
          reject(new Error(`è§£æå¤±è´¥: ${response.error_message}`));
          return;
        }

        resolve({
          content: response.content,
          metadata: response.metadata
        });
      });
    });
  }

  healthCheck() {
    return new Promise((resolve, reject) => {
      const request = { service: 'parser.ParserService' };

      const deadline = new Date();
      deadline.setSeconds(deadline.getSeconds() + 5);

      this.client.HealthCheck(request, { deadline }, (error, response) => {
        if (error) {
          resolve(false);
          return;
        }

        resolve(response.status === 'SERVING');
      });
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
  const client = new ParserClient('localhost', 50051);

  try {
    const result = await client.parseFile('report.pdf');
    console.log(`è§£ææˆåŠŸ: ${result.content.length} å­—ç¬¦`);
    console.log(`é¡µæ•°: ${result.metadata.page_count}`);
  } catch (error) {
    console.error('è§£æå¤±è´¥:', error);
  }
}

main();
```

---

## é«˜çº§ç‰¹æ€§

### 1. å®¢æˆ·ç«¯ä¾§é™çº§ç­–ç•¥ï¼ˆå¯é€‰ï¼‰

å¦‚æœä½ å¸Œæœ›åœ¨ gRPC æœåŠ¡ä¸å¯ç”¨æ—¶é™çº§åˆ°æœ¬åœ°è§£æï¼Œå¯ä»¥åœ¨**è°ƒç”¨æ–¹**å®ç°é™çº§ç­–ç•¥ï¼š

```python
from parsers.grpc.client import ParserGrpcClient
from parsers import create_parser
from pathlib import Path
import asyncio
import logging

logger = logging.getLogger(__name__)

def parse_file_with_fallback(file_path: str, **options) -> dict:
    """å¸¦é™çº§ç­–ç•¥çš„æ–‡ä»¶è§£æ

    ä¼˜å…ˆä½¿ç”¨ gRPC æœåŠ¡ï¼Œå¤±è´¥æ—¶é™çº§åˆ°æœ¬åœ°è§£æã€‚

    æ³¨æ„ï¼šé™çº§ç­–ç•¥åº”åœ¨è°ƒç”¨æ–¹å®ç°ï¼Œè€ŒéæœåŠ¡ç«¯ã€‚
    """
    try:
        # ä¼˜å…ˆï¼šgRPC æœåŠ¡è°ƒç”¨
        with ParserGrpcClient() as client:
            with open(file_path, 'rb') as f:
                file_content = f.read()

            result = client.parse_bytes(
                file_content=file_content,
                file_name=Path(file_path).name,
                **options
            )

            logger.info(f"gRPC è§£ææˆåŠŸ: {file_path}")
            return result

    except Exception as e:
        logger.warning(f"gRPC è°ƒç”¨å¤±è´¥ï¼Œé™çº§åˆ°æœ¬åœ°è§£æ: {e}")

        # é™çº§ï¼šæœ¬åœ°è§£æ
        try:
            parser = create_parser(Path(file_path).suffix)

            with open(file_path, 'rb') as f:
                file_content = f.read()

            content = asyncio.run(parser.parse(file_content))

            return {
                "content": content,
                "metadata": {
                    "page_count": 0,
                    "image_count": 0,
                    "table_count": 0,
                    "parse_time_ms": 0.0
                }
            }

        except Exception as local_error:
            logger.error(f"æœ¬åœ°è§£æä¹Ÿå¤±è´¥: {local_error}")
            raise RuntimeError(f"è§£æå¤±è´¥: gRPC å’Œæœ¬åœ°è§£æå‡å¤±è´¥") from e

# ä½¿ç”¨ç¤ºä¾‹
result = parse_file_with_fallback("report.pdf", enable_ocr=True)
```

**é™çº§ç­–ç•¥è¦ç‚¹**ï¼š
- âœ… åœ¨**è°ƒç”¨æ–¹**å®ç°é™çº§ç­–ç•¥ï¼ˆæœ‰æ–‡ä»¶ç³»ç»Ÿè®¿é—®æƒé™ï¼‰
- âŒ ä¸è¦åœ¨**æœåŠ¡ç«¯**å®ç°é™çº§ç­–ç•¥ï¼ˆæœåŠ¡ç«¯åªæ¥æ”¶äºŒè¿›åˆ¶å†…å®¹ï¼Œæ— æ–‡ä»¶è·¯å¾„ï¼‰
- âœ… é™çº§åˆ°æœ¬åœ°è§£ææ—¶ï¼Œéœ€è¦å¼•å…¥ Parsers é¡¹ç›®çš„è§£æå™¨æ¨¡å—

### 2. è¿æ¥æ± ç®¡ç†

**åœºæ™¯**ï¼šFastAPIã€Django ç­‰ Web æ¡†æ¶ä¸­å¤ç”¨ gRPC è¿æ¥ã€‚

```python
from parsers.grpc.client import get_grpc_client

# ä½¿ç”¨å…¨å±€å•ä¾‹å®¢æˆ·ç«¯ï¼ˆè‡ªåŠ¨è¿æ¥æ± ç®¡ç†ï¼‰
client = get_grpc_client()

# å¤šæ¬¡è°ƒç”¨ï¼Œå¤ç”¨åŒä¸€è¿æ¥
for file_path in file_list:
    with open(file_path, 'rb') as f:
        content = f.read()

    result = client.parse_bytes(content, file_path)
    # å¤„ç†ç»“æœ...
```

### 3. æ‰¹é‡è§£æ

**åœºæ™¯**ï¼šæ‰¹é‡å¤„ç†å¤šä¸ªæ–‡æ¡£ã€‚

```python
from parsers.grpc.client import ParserGrpcClient
from concurrent.futures import ThreadPoolExecutor, as_completed

def batch_parse_files(file_paths: list, max_workers=5):
    """æ‰¹é‡è§£ææ–‡ä»¶ï¼ˆå¹¶å‘è°ƒç”¨ï¼‰"""
    client = ParserGrpcClient()
    client.connect()

    results = {}

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # æäº¤æ‰€æœ‰ä»»åŠ¡
        future_to_file = {
            executor.submit(parse_single_file, client, fp): fp
            for fp in file_paths
        }

        # æ”¶é›†ç»“æœ
        for future in as_completed(future_to_file):
            file_path = future_to_file[future]
            try:
                result = future.result()
                results[file_path] = result
            except Exception as e:
                results[file_path] = {"error": str(e)}

    client.close()
    return results

def parse_single_file(client, file_path):
    """è§£æå•ä¸ªæ–‡ä»¶"""
    with open(file_path, 'rb') as f:
        content = f.read()

    return client.parse_bytes(content, file_path)

# ä½¿ç”¨ç¤ºä¾‹
file_paths = ["doc1.pdf", "doc2.docx", "doc3.pptx"]
results = batch_parse_files(file_paths, max_workers=3)

for file_path, result in results.items():
    if "error" in result:
        print(f"âŒ {file_path}: {result['error']}")
    else:
        print(f"âœ… {file_path}: {len(result['content'])} å­—ç¬¦")
```

### 4. å¼‚æ­¥è°ƒç”¨ï¼ˆPython asyncioï¼‰

**åœºæ™¯**ï¼šFastAPI ç­‰å¼‚æ­¥æ¡†æ¶ä¸­çš„å¼‚æ­¥è°ƒç”¨ã€‚

```python
import grpc
import asyncio
from parsers.grpc.generated import parser_pb2, parser_pb2_grpc

class AsyncParserClient:
    """å¼‚æ­¥ Parser å®¢æˆ·ç«¯"""

    def __init__(self, host="localhost", port=50051):
        self.channel = grpc.aio.insecure_channel(
            f"{host}:{port}",
            options=[
                ('grpc.max_send_message_length', 50 * 1024 * 1024),
                ('grpc.max_receive_message_length', 50 * 1024 * 1024),
            ]
        )
        self.stub = parser_pb2_grpc.ParserServiceStub(self.channel)

    async def parse_bytes(self, file_content: bytes, file_name: str):
        """å¼‚æ­¥è§£ææ–‡ä»¶"""
        request = parser_pb2.ParseRequest(
            file_content=file_content,
            file_name=file_name,
            options=parser_pb2.ParseOptions(enable_ocr=True)
        )

        response = await self.stub.ParseFile(request, timeout=300)

        if response.error_message:
            raise RuntimeError(response.error_message)

        return {
            "content": response.content,
            "metadata": {
                "page_count": response.metadata.page_count,
                "parse_time_ms": response.metadata.parse_time_ms
            }
        }

    async def close(self):
        """å…³é—­è¿æ¥"""
        await self.channel.close()

# ä½¿ç”¨ç¤ºä¾‹ï¼ˆFastAPIï¼‰
from fastapi import FastAPI, UploadFile, File

app = FastAPI()
client = AsyncParserClient()

@app.post("/api/parse")
async def parse_document(file: UploadFile = File(...)):
    """å¼‚æ­¥è§£ææ–‡æ¡£"""
    file_content = await file.read()
    result = await client.parse_bytes(file_content, file.filename)
    return result

@app.on_event("shutdown")
async def shutdown_event():
    """åº”ç”¨å…³é—­æ—¶æ¸…ç†èµ„æº"""
    await client.close()
```

---

## é”™è¯¯å¤„ç†ä¸é‡è¯•ç­–ç•¥

### å¸¸è§é”™è¯¯ç±»å‹

| é”™è¯¯ç±»å‹ | gRPC çŠ¶æ€ç  | è¯´æ˜ | å»ºè®®å¤„ç† |
|---------|------------|------|---------|
| è¿æ¥å¤±è´¥ | UNAVAILABLE | æœåŠ¡ç«¯ä¸å¯è¾¾ | é‡è¯• 3 æ¬¡ï¼Œé—´éš” 1/2/3 ç§’ |
| è¶…æ—¶ | DEADLINE_EXCEEDED | è¯·æ±‚è¶…æ—¶ | å¢åŠ è¶…æ—¶æ—¶é—´æˆ–ä¼˜åŒ–æ–‡æ¡£ |
| æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ | INVALID_ARGUMENT | ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ | æ£€æŸ¥æ–‡ä»¶æ‰©å±•å |
| æ–‡ä»¶è¿‡å¤§ | RESOURCE_EXHAUSTED | æ–‡ä»¶è¶…è¿‡ 50MB | æ‹†åˆ†æ–‡ä»¶æˆ–è°ƒæ•´é…ç½® |
| æœåŠ¡ç«¯é”™è¯¯ | INTERNAL | æœåŠ¡ç«¯å†…éƒ¨é”™è¯¯ | æŸ¥çœ‹æœåŠ¡ç«¯æ—¥å¿— |

### é‡è¯•ç­–ç•¥å®ç°

```python
import time
import grpc
from typing import Callable, TypeVar, Any

T = TypeVar('T')

def retry_on_failure(
    func: Callable[..., T],
    max_retries: int = 3,
    backoff_factor: float = 1.0,
    retryable_errors: tuple = (grpc.StatusCode.UNAVAILABLE, grpc.StatusCode.DEADLINE_EXCEEDED)
) -> T:
    """é€šç”¨é‡è¯•è£…é¥°å™¨

    Args:
        func: è¦é‡è¯•çš„å‡½æ•°
        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•°
        backoff_factor: é€€é¿å› å­ï¼ˆç§’ï¼‰
        retryable_errors: å¯é‡è¯•çš„ gRPC çŠ¶æ€ç 

    Returns:
        å‡½æ•°æ‰§è¡Œç»“æœ

    Raises:
        æœ€åä¸€æ¬¡å°è¯•çš„å¼‚å¸¸
    """
    for attempt in range(max_retries):
        try:
            return func()

        except grpc.RpcError as e:
            # æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
            if e.code() not in retryable_errors:
                raise

            # æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
            if attempt == max_retries - 1:
                raise

            # æŒ‡æ•°é€€é¿
            wait_time = backoff_factor * (2 ** attempt)
            print(f"é‡è¯• {attempt + 1}/{max_retries}ï¼Œç­‰å¾… {wait_time} ç§’...")
            time.sleep(wait_time)

# ä½¿ç”¨ç¤ºä¾‹
def parse_with_retry(client, file_content, file_name):
    """å¸¦é‡è¯•çš„è§£æ"""
    return retry_on_failure(
        lambda: client.parse_bytes(file_content, file_name),
        max_retries=3,
        backoff_factor=1.0
    )

# è°ƒç”¨
result = parse_with_retry(client, file_content, "report.pdf")
```

### é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

```python
from parsers.grpc.client import ParserGrpcClient
import grpc
import logging

logger = logging.getLogger(__name__)

def parse_file_safe(file_path: str):
    """å®‰å…¨çš„æ–‡ä»¶è§£æï¼ˆå®Œæ•´é”™è¯¯å¤„ç†ï¼‰"""
    client = ParserGrpcClient()

    try:
        client.connect()

        # è¯»å–æ–‡ä»¶
        with open(file_path, 'rb') as f:
            file_content = f.read()

        # è§£ææ–‡ä»¶
        result = client.parse_bytes(file_content, file_path)

        logger.info(f"è§£ææˆåŠŸ: {file_path}")
        return {"status": "success", "data": result}

    except FileNotFoundError:
        logger.error(f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        return {"status": "error", "message": "æ–‡ä»¶ä¸å­˜åœ¨"}

    except grpc.RpcError as e:
        # gRPC é”™è¯¯å¤„ç†
        if e.code() == grpc.StatusCode.UNAVAILABLE:
            logger.error("gRPC æœåŠ¡ä¸å¯ç”¨")
            return {"status": "error", "message": "æœåŠ¡ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•"}

        elif e.code() == grpc.StatusCode.DEADLINE_EXCEEDED:
            logger.error("gRPC è¯·æ±‚è¶…æ—¶")
            return {"status": "error", "message": "è§£æè¶…æ—¶ï¼Œæ–‡æ¡£å¯èƒ½è¿‡å¤§"}

        elif e.code() == grpc.StatusCode.INVALID_ARGUMENT:
            logger.error("æ— æ•ˆå‚æ•°")
            return {"status": "error", "message": "æ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ"}

        else:
            logger.error(f"gRPC é”™è¯¯: {e.code()}: {e.details()}")
            return {"status": "error", "message": f"æœåŠ¡è°ƒç”¨å¤±è´¥: {e.details()}"}

    except RuntimeError as e:
        # æœåŠ¡ç«¯è¿”å›çš„ä¸šåŠ¡é”™è¯¯
        logger.error(f"è§£æå¤±è´¥: {e}")
        return {"status": "error", "message": str(e)}

    except Exception as e:
        # æœªçŸ¥é”™è¯¯
        logger.exception(f"æœªçŸ¥é”™è¯¯: {e}")
        return {"status": "error", "message": "ç³»ç»Ÿé”™è¯¯"}

    finally:
        client.close()

# ä½¿ç”¨ç¤ºä¾‹
result = parse_file_safe("report.pdf")

if result["status"] == "success":
    print(f"å†…å®¹: {result['data']['content'][:100]}...")
else:
    print(f"é”™è¯¯: {result['message']}")
```

---

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. è¿æ¥å¤ç”¨

**é—®é¢˜**ï¼šæ¯æ¬¡è°ƒç”¨éƒ½åˆ›å»ºæ–°è¿æ¥ï¼Œå¼€é”€å¤§ã€‚

**è§£å†³**ï¼šä½¿ç”¨å…¨å±€å•ä¾‹å®¢æˆ·ç«¯å¤ç”¨è¿æ¥ã€‚

```python
# âŒ ä¸æ¨èï¼šæ¯æ¬¡åˆ›å»ºæ–°è¿æ¥
def parse_bad(file_path):
    with ParserGrpcClient() as client:  # æ¯æ¬¡åˆ›å»ºæ–°è¿æ¥
        result = client.parse_bytes(...)
    return result

# âœ… æ¨èï¼šå¤ç”¨å…¨å±€è¿æ¥
from parsers.grpc.client import get_grpc_client

client = get_grpc_client()  # å…¨å±€å•ä¾‹

def parse_good(file_path):
    result = client.parse_bytes(...)  # å¤ç”¨è¿æ¥
    return result
```

### 2. æ‰¹é‡å¤„ç†

**é—®é¢˜**ï¼šä¸²è¡Œå¤„ç†å¤šä¸ªæ–‡ä»¶ï¼Œæ•ˆç‡ä½ã€‚

**è§£å†³**ï¼šä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘è°ƒç”¨ã€‚

```python
from concurrent.futures import ThreadPoolExecutor

def batch_parse(file_paths):
    client = get_grpc_client()

    with ThreadPoolExecutor(max_workers=5) as executor:
        futures = [
            executor.submit(client.parse_bytes, open(fp, 'rb').read(), fp)
            for fp in file_paths
        ]

        results = [f.result() for f in futures]

    return results
```

### 3. ç¦ç”¨ä¸å¿…è¦çš„ OCR

**é—®é¢˜**ï¼šçº¯æ–‡æœ¬ PDF ä¹Ÿæ‰§è¡Œ OCRï¼Œæµªè´¹èµ„æºã€‚

**è§£å†³**ï¼šæ ¹æ®æ–‡æ¡£ç±»å‹é€‰æ‹©æ€§å¯ç”¨ OCRã€‚

```python
# çº¯æ–‡æœ¬æ–‡æ¡£ï¼šç¦ç”¨ OCR
result = client.parse_bytes(
    file_content,
    "text-based.pdf",
    enable_ocr=False  # èŠ‚çœ 80% è§£ææ—¶é—´
)

# æ‰«æç‰ˆæ–‡æ¡£ï¼šå¯ç”¨ OCR
result = client.parse_bytes(
    file_content,
    "scanned.pdf",
    enable_ocr=True  # å¿…é¡»å¯ç”¨
)
```

### 4. è°ƒæ•´è¶…æ—¶æ—¶é—´

**é—®é¢˜**ï¼šé»˜è®¤è¶…æ—¶ 300 ç§’å¯èƒ½ä¸å¤Ÿã€‚

**è§£å†³**ï¼šæ ¹æ®æ–‡æ¡£å¤§å°åŠ¨æ€è°ƒæ•´è¶…æ—¶ã€‚

```python
import os

def parse_with_dynamic_timeout(file_path):
    # æ ¹æ®æ–‡ä»¶å¤§å°è®¡ç®—è¶…æ—¶æ—¶é—´
    file_size_mb = os.path.getsize(file_path) / (1024 * 1024)
    timeout = max(300, file_size_mb * 10)  # æ¯ MB 10 ç§’

    client = ParserGrpcClient(timeout=timeout)
    # ... è§£ææ–‡ä»¶
```

### 5. å‹ç¼©å¤§æ–‡ä»¶

**é—®é¢˜**ï¼šä¸Šä¼  50MB æ–‡ä»¶è€—æ—¶é•¿ã€‚

**è§£å†³**ï¼šå®¢æˆ·ç«¯å‹ç¼©åä¸Šä¼ ï¼ˆéœ€æœåŠ¡ç«¯æ”¯æŒï¼‰ã€‚

```python
import gzip

def parse_large_file(file_path):
    # è¯»å–å¹¶å‹ç¼©æ–‡ä»¶
    with open(file_path, 'rb') as f:
        file_content = f.read()

    compressed = gzip.compress(file_content)

    # ä¸Šä¼ å‹ç¼©å†…å®¹ï¼ˆéœ€æœåŠ¡ç«¯è§£å‹ï¼‰
    result = client.parse_bytes(compressed, file_path)
    return result
```

### 6. ç¼“å­˜è§£æç»“æœ

**é—®é¢˜**ï¼šé‡å¤è§£æåŒä¸€æ–‡ä»¶ã€‚

**è§£å†³**ï¼šä½¿ç”¨ç¼“å­˜ï¼ˆRedisã€æœ¬åœ°æ–‡ä»¶ï¼‰ã€‚

```python
import hashlib
import json

def parse_with_cache(file_path, cache_dir="./cache"):
    # è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
    with open(file_path, 'rb') as f:
        file_hash = hashlib.sha256(f.read()).hexdigest()

    cache_file = f"{cache_dir}/{file_hash}.json"

    # æ£€æŸ¥ç¼“å­˜
    if os.path.exists(cache_file):
        with open(cache_file, 'r') as f:
            return json.load(f)

    # è§£ææ–‡ä»¶
    result = client.parse_bytes(...)

    # ä¿å­˜ç¼“å­˜
    os.makedirs(cache_dir, exist_ok=True)
    with open(cache_file, 'w') as f:
        json.dump(result, f)

    return result
```

---

## æ•…éšœæ’æŸ¥æŒ‡å—

### é—®é¢˜ 1ï¼šè¿æ¥è¢«æ‹’ç»

**é”™è¯¯ä¿¡æ¯**ï¼š
```
grpc.RpcError: <_InactiveRpcError of RPC that terminated with:
    status = StatusCode.UNAVAILABLE
    details = "failed to connect to all addresses"
```

**å¯èƒ½åŸå› **ï¼š
1. gRPC æœåŠ¡ç«¯æœªå¯åŠ¨
2. ç«¯å£é…ç½®é”™è¯¯
3. é˜²ç«å¢™é˜»æ­¢è¿æ¥
4. ç½‘ç»œä¸é€š

**æ’æŸ¥æ­¥éª¤**ï¼š

```bash
# 1. æ£€æŸ¥æœåŠ¡ç«¯æ˜¯å¦è¿è¡Œ
docker ps | grep parsers-grpc
# æˆ–
kubectl get pods | grep parsers

# 2. æ£€æŸ¥ç«¯å£ç›‘å¬
netstat -tlnp | grep 50051
# æˆ–
lsof -i :50051

# 3. æµ‹è¯•ç½‘ç»œè¿é€šæ€§
telnet localhost 50051
# æˆ–
nc -zv localhost 50051

# 4. æ£€æŸ¥é˜²ç«å¢™
sudo iptables -L -n | grep 50051
# æˆ–
sudo firewall-cmd --list-ports
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
- å¯åŠ¨ gRPC æœåŠ¡ç«¯
- æ£€æŸ¥ `PARSER_GRPC_PORT` ç¯å¢ƒå˜é‡
- å¼€æ”¾ç«¯å£ï¼š`sudo firewall-cmd --add-port=50051/tcp --permanent`

### é—®é¢˜ 2ï¼šè¯·æ±‚è¶…æ—¶

**é”™è¯¯ä¿¡æ¯**ï¼š
```
grpc.RpcError: <_InactiveRpcError of RPC that terminated with:
    status = StatusCode.DEADLINE_EXCEEDED
    details = "Deadline Exceeded"
```

**å¯èƒ½åŸå› **ï¼š
1. æ–‡æ¡£è¿‡å¤§æˆ–å¤æ‚ï¼ˆæ‰«æç‰ˆ PDFï¼‰
2. æœåŠ¡ç«¯èµ„æºä¸è¶³ï¼ˆCPU/å†…å­˜ï¼‰
3. ç½‘ç»œå»¶è¿Ÿé«˜

**æ’æŸ¥æ­¥éª¤**ï¼š

```bash
# 1. æ£€æŸ¥æ–‡æ¡£å¤§å°
ls -lh report.pdf

# 2. æ£€æŸ¥æœåŠ¡ç«¯èµ„æº
docker stats parsers-grpc
# æˆ–
kubectl top pod parsers-grpc-xxx

# 3. æŸ¥çœ‹æœåŠ¡ç«¯æ—¥å¿—
docker logs -f parsers-grpc
# æˆ–
kubectl logs -f parsers-grpc-xxx
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
- å¢åŠ å®¢æˆ·ç«¯è¶…æ—¶æ—¶é—´ï¼š`ParserGrpcClient(timeout=600)`
- ä¼˜åŒ–æ–‡æ¡£ï¼šé™ä½å›¾åƒåˆ†è¾¨ç‡
- æ‰©å®¹æœåŠ¡ç«¯ï¼šå¢åŠ  CPU/å†…å­˜
- ç¦ç”¨ OCRï¼ˆå¦‚æœä¸éœ€è¦ï¼‰ï¼š`enable_ocr=False`

### é—®é¢˜ 3ï¼šæ–‡ä»¶æ ¼å¼ä¸æ”¯æŒ

**é”™è¯¯ä¿¡æ¯**ï¼š
```
RuntimeError: ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼š.xlsx
```

**æ”¯æŒçš„æ ¼å¼**ï¼š
- âœ… PDFï¼ˆ`.pdf`ï¼‰
- âœ… DOCXï¼ˆ`.docx`ï¼‰
- âœ… PPTXï¼ˆ`.pptx`ï¼‰
- âœ… Markdownï¼ˆ`.md`ã€`.markdown`ï¼‰

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦æ­£ç¡®
- å°†ä¸æ”¯æŒçš„æ ¼å¼è½¬æ¢ä¸º PDF

### é—®é¢˜ 4ï¼šæ–‡ä»¶è¿‡å¤§

**é”™è¯¯ä¿¡æ¯**ï¼š
```
grpc.RpcError: <_InactiveRpcError of RPC that terminated with:
    status = StatusCode.RESOURCE_EXHAUSTED
    details = "Received message larger than max"
```

**åŸå› **ï¼šæ–‡ä»¶è¶…è¿‡ 50MBï¼ˆé»˜è®¤é™åˆ¶ï¼‰ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

**æ–¹æ¡ˆ 1ï¼šè°ƒæ•´å®¢æˆ·ç«¯é…ç½®**
```python
client = ParserGrpcClient()
client._channel = grpc.insecure_channel(
    client.address,
    options=[
        ('grpc.max_send_message_length', 100 * 1024 * 1024),  # 100MB
        ('grpc.max_receive_message_length', 100 * 1024 * 1024),
    ]
)
```

**æ–¹æ¡ˆ 2ï¼šè°ƒæ•´æœåŠ¡ç«¯é…ç½®**
```python
# grpc/server.py
server = grpc.aio.server(
    options=[
        ('grpc.max_send_message_length', 100 * 1024 * 1024),
        ('grpc.max_receive_message_length', 100 * 1024 * 1024),
    ]
)
```

**æ–¹æ¡ˆ 3ï¼šæ‹†åˆ†å¤§æ–‡ä»¶**
```python
# å°†å¤§ PDF æ‹†åˆ†ä¸ºå¤šä¸ªå° PDF
from PyPDF2 import PdfReader, PdfWriter

def split_pdf(input_path, pages_per_chunk=50):
    reader = PdfReader(input_path)
    total_pages = len(reader.pages)

    chunks = []
    for i in range(0, total_pages, pages_per_chunk):
        writer = PdfWriter()
        for j in range(i, min(i + pages_per_chunk, total_pages)):
            writer.add_page(reader.pages[j])

        chunk_path = f"chunk_{i//pages_per_chunk}.pdf"
        with open(chunk_path, 'wb') as f:
            writer.write(f)

        chunks.append(chunk_path)

    return chunks
```

### é—®é¢˜ 5ï¼šå¥åº·æ£€æŸ¥å¤±è´¥

**ç°è±¡**ï¼šKubernetes pod çŠ¶æ€ä¸º `Unhealthy`ã€‚

**æ’æŸ¥æ­¥éª¤**ï¼š

```bash
# 1. æŸ¥çœ‹ pod çŠ¶æ€
kubectl describe pod parsers-grpc-xxx

# 2. æ£€æŸ¥å¥åº·æ£€æŸ¥æ—¥å¿—
kubectl logs parsers-grpc-xxx

# 3. æ‰‹åŠ¨æ‰§è¡Œå¥åº·æ£€æŸ¥
kubectl exec parsers-grpc-xxx -- ./scripts/grpc_health_check.sh

# 4. ä½¿ç”¨ Python å®¢æˆ·ç«¯æµ‹è¯•
kubectl exec -it parsers-grpc-xxx -- python3 -c "
from parsers.grpc.client import ParserGrpcClient
client = ParserGrpcClient()
print('å¥åº·çŠ¶æ€:', 'æ­£å¸¸' if client.health_check() else 'å¼‚å¸¸')
"
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
- å¢åŠ å¥åº·æ£€æŸ¥è¶…æ—¶æ—¶é—´
- å¢åŠ å¯åŠ¨å»¶è¿Ÿæ—¶é—´ï¼ˆ`initialDelaySeconds`ï¼‰
- æ£€æŸ¥ OCR æ¨¡å‹æ˜¯å¦åŠ è½½å®Œæˆ

### é—®é¢˜ 6ï¼šOCR è¯†åˆ«å‡†ç¡®ç‡ä½

**ç°è±¡**ï¼šæ‰«æç‰ˆ PDF è¯†åˆ«é”™è¯¯å¤šã€‚

**å¯èƒ½åŸå› **ï¼š
1. å›¾åƒè´¨é‡å·®ï¼ˆåˆ†è¾¨ç‡ä½ã€æ¨¡ç³Šï¼‰
2. æ–‡å­—å€¾æ–œæˆ–æ—‹è½¬
3. OCR è¯­è¨€è®¾ç½®é”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š

```python
# 1. è°ƒæ•´ OCR è¯­è¨€
result = client.parse_bytes(
    file_content,
    "english.pdf",
    language="en"  # è‹±æ–‡æ–‡æ¡£
)

# 2. æé«˜å›¾åƒè´¨é‡ï¼ˆé¢„å¤„ç†ï¼‰
from PIL import Image
import io

def enhance_image_quality(image_bytes):
    """æé«˜å›¾åƒè´¨é‡"""
    img = Image.open(io.BytesIO(image_bytes))

    # æ”¾å¤§å›¾åƒ
    img = img.resize((img.width * 2, img.height * 2), Image.LANCZOS)

    # å¢å¼ºå¯¹æ¯”åº¦
    from PIL import ImageEnhance
    enhancer = ImageEnhance.Contrast(img)
    img = enhancer.enhance(1.5)

    # è½¬æ¢ä¸ºå­—èŠ‚
    output = io.BytesIO()
    img.save(output, format='PNG')
    return output.getvalue()

# 3. æ£€æŸ¥ CPU æŒ‡ä»¤é›†æ”¯æŒ
# AVX æŒ‡ä»¤é›†å¯æå‡ OCR æ€§èƒ½ 2-3 å€
import numpy as np
print('AVX æ”¯æŒ:', hasattr(np.core._multiarray_umath, '__cpu_features__'))
```

---

## å¸¸è§é—®é¢˜ FAQ

### Q1: å¦‚ä½•å¤„ç†ä¸åŒæ ¼å¼çš„æ–‡æ¡£ï¼Ÿ

**A**: Parsers æœåŠ¡æ”¯æŒ PDFã€DOCXã€PPTXã€Markdown å››ç§æ ¼å¼ï¼Œé€šè¿‡æ–‡ä»¶åè‡ªåŠ¨è¯†åˆ«æ ¼å¼ã€‚

```python
# è‡ªåŠ¨è¯†åˆ«æ ¼å¼ï¼ˆé€šè¿‡æ–‡ä»¶åï¼‰
result_pdf = client.parse_bytes(pdf_content, "report.pdf")
result_docx = client.parse_bytes(docx_content, "report.docx")
result_pptx = client.parse_bytes(pptx_content, "report.pptx")
result_md = client.parse_bytes(md_content, "report.md")
```

### Q2: å¦‚ä½•åœ¨ Docker å®¹å™¨ä¸­è°ƒç”¨ gRPC æœåŠ¡ï¼Ÿ

**A**: ä½¿ç”¨ Docker ç½‘ç»œæˆ– Kubernetes Serviceã€‚

**Docker Compose ç¤ºä¾‹**ï¼š
```yaml
version: '3.8'

services:
  parsers-grpc:
    image: parsers-grpc:latest
    ports:
      - "50051:50051"

  your-app:
    image: your-app:latest
    environment:
      - PARSER_GRPC_HOST=parsers-grpc  # ä½¿ç”¨æœåŠ¡å
      - PARSER_GRPC_PORT=50051
    depends_on:
      - parsers-grpc
```

**Kubernetes ç¤ºä¾‹**ï¼š
```python
# ä½¿ç”¨ Kubernetes Service DNS
client = ParserGrpcClient(
    host="parsers-grpc-service.default.svc.cluster.local",
    port=50051
)
```

### Q3: å¦‚ä½•ä¼˜åŒ–å¤§æ‰¹é‡æ–‡æ¡£è§£æï¼Ÿ

**A**: ä½¿ç”¨å¹¶å‘è°ƒç”¨ + è¿æ¥å¤ç”¨ã€‚

```python
from concurrent.futures import ThreadPoolExecutor

def batch_parse_optimized(file_paths, max_workers=10):
    """ä¼˜åŒ–çš„æ‰¹é‡è§£æ"""
    client = get_grpc_client()  # å…¨å±€å•ä¾‹ï¼Œè¿æ¥å¤ç”¨

    def parse_one(fp):
        with open(fp, 'rb') as f:
            return client.parse_bytes(f.read(), fp)

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        results = list(executor.map(parse_one, file_paths))

    return results
```

### Q4: å¦‚ä½•ç›‘æ§ gRPC æœåŠ¡çš„æ€§èƒ½ï¼Ÿ

**A**: ä½¿ç”¨ Prometheus + Grafanaã€‚

**æœåŠ¡ç«¯æ·»åŠ  Prometheus æŒ‡æ ‡**ï¼š
```python
from prometheus_client import Counter, Histogram, start_http_server

# å®šä¹‰æŒ‡æ ‡
parse_requests = Counter('parse_requests_total', 'Total parse requests')
parse_duration = Histogram('parse_duration_seconds', 'Parse duration')
parse_errors = Counter('parse_errors_total', 'Total parse errors')

# åœ¨ RPC æ–¹æ³•ä¸­è®°å½•
@parse_duration.time()
def ParseFile(self, request, context):
    parse_requests.inc()
    try:
        # ... è§£æé€»è¾‘
        return response
    except Exception as e:
        parse_errors.inc()
        raise

# å¯åŠ¨ Prometheus HTTP æœåŠ¡å™¨
start_http_server(8000)
```

**Prometheus é…ç½®**ï¼š
```yaml
scrape_configs:
  - job_name: 'parsers-grpc'
    static_configs:
      - targets: ['parsers-grpc:8000']
```

### Q5: å¦‚ä½•å®ç°æ–­ç‚¹ç»­ä¼ ï¼Ÿ

**A**: gRPC ä¸æ”¯æŒæ–­ç‚¹ç»­ä¼ ï¼Œå»ºè®®æ‹†åˆ†å¤§æ–‡ä»¶æˆ–ä½¿ç”¨åˆ†å—ä¸Šä¼ ã€‚

```python
def chunked_parse(file_path, chunk_size_mb=10):
    """åˆ†å—è§£æå¤§æ–‡ä»¶"""
    import os

    file_size = os.path.getsize(file_path)
    chunk_size = chunk_size_mb * 1024 * 1024

    results = []

    with open(file_path, 'rb') as f:
        chunk_num = 0
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break

            # è§£ææ¯ä¸ªåˆ†å—
            result = client.parse_bytes(
                chunk,
                f"{file_path}.part{chunk_num}"
            )

            results.append(result['content'])
            chunk_num += 1

    # åˆå¹¶ç»“æœ
    return '\n\n'.join(results)
```

### Q6: å¦‚ä½•å¤„ç†åŠ å¯†çš„ PDFï¼Ÿ

**A**: è§£å¯†åå†ä¸Šä¼ ã€‚

```python
from PyPDF2 import PdfReader, PdfWriter

def parse_encrypted_pdf(file_path, password):
    """è§£æåŠ å¯† PDF"""
    # è§£å¯† PDF
    reader = PdfReader(file_path)
    reader.decrypt(password)

    # åˆ›å»ºè§£å¯†åçš„ä¸´æ—¶æ–‡ä»¶
    writer = PdfWriter()
    for page in reader.pages:
        writer.add_page(page)

    temp_file = "/tmp/decrypted.pdf"
    with open(temp_file, 'wb') as f:
        writer.write(f)

    # è§£æè§£å¯†åçš„æ–‡ä»¶
    with open(temp_file, 'rb') as f:
        result = client.parse_bytes(f.read(), "decrypted.pdf")

    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    os.remove(temp_file)

    return result
```

### Q7: å¦‚ä½•è·å–è§£æè¿›åº¦ï¼Ÿ

**A**: gRPC å•å‘ RPC ä¸æ”¯æŒè¿›åº¦å›è°ƒï¼Œå»ºè®®ä½¿ç”¨æµå¼ RPCï¼ˆéœ€æœåŠ¡ç«¯æ”¯æŒï¼‰æˆ–è½®è¯¢çŠ¶æ€ã€‚

**æ–¹æ¡ˆ 1ï¼šå¼‚æ­¥ä»»åŠ¡ + è½®è¯¢**
```python
# æäº¤å¼‚æ­¥è§£æä»»åŠ¡
task_id = submit_parse_task(file_content, file_name)

# è½®è¯¢ä»»åŠ¡çŠ¶æ€
while True:
    status = check_task_status(task_id)

    if status['state'] == 'completed':
        result = get_task_result(task_id)
        break

    elif status['state'] == 'failed':
        raise RuntimeError(status['error'])

    time.sleep(1)
```

**æ–¹æ¡ˆ 2ï¼šWebSocket é€šçŸ¥**
```python
# æäº¤ä»»åŠ¡
task_id = submit_parse_task(file_content, file_name)

# ç›‘å¬ WebSocket è¿›åº¦
ws = websocket.WebSocket()
ws.connect(f"ws://server/task/{task_id}/progress")

for message in ws:
    data = json.loads(message)
    print(f"è¿›åº¦: {data['progress']}%")

    if data['state'] == 'completed':
        result = data['result']
        break
```

### Q8: å¦‚ä½•é™æµå’Œé…é¢ç®¡ç†ï¼Ÿ

**A**: åœ¨è°ƒç”¨æ–¹å®ç°ä»¤ç‰Œæ¡¶ç®—æ³•ã€‚

```python
import time
import threading

class RateLimiter:
    """ä»¤ç‰Œæ¡¶é™æµå™¨"""

    def __init__(self, rate, capacity):
        self.rate = rate          # æ¯ç§’ç”Ÿæˆ token æ•°
        self.capacity = capacity  # æ¡¶å®¹é‡
        self.tokens = capacity
        self.lock = threading.Lock()
        self.last_update = time.time()

    def acquire(self, tokens=1):
        """è·å– tokenï¼ˆé˜»å¡ï¼‰"""
        with self.lock:
            # æ›´æ–° token æ•°é‡
            now = time.time()
            elapsed = now - self.last_update
            self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)
            self.last_update = now

            # ç­‰å¾…è¶³å¤Ÿçš„ token
            while self.tokens < tokens:
                time.sleep(0.1)
                now = time.time()
                elapsed = now - self.last_update
                self.tokens = min(self.capacity, self.tokens + elapsed * self.rate)
                self.last_update = now

            # æ¶ˆè´¹ token
            self.tokens -= tokens

# ä½¿ç”¨ç¤ºä¾‹
limiter = RateLimiter(rate=10, capacity=100)  # æ¯ç§’ 10 æ¬¡ï¼Œæœ€å¤šç§¯ç´¯ 100 æ¬¡

def parse_with_rate_limit(file_content, file_name):
    limiter.acquire()  # è·å– token
    return client.parse_bytes(file_content, file_name)
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº† Parsers gRPC å¾®æœåŠ¡çš„å®Œæ•´ä½¿ç”¨æŒ‡å—ï¼Œæ¶µç›–ï¼š

1. **å¿«é€Ÿå¼€å§‹**ï¼š5 åˆ†é’Ÿå¿«é€Ÿä½“éªŒ
2. **æœåŠ¡ç«¯éƒ¨ç½²**ï¼šDocker Compose / Kubernetes
3. **API åè®®**ï¼šå®Œæ•´çš„ Proto å®šä¹‰å’Œæ¥å£è¯´æ˜
4. **å¤šè¯­è¨€å®¢æˆ·ç«¯**ï¼šPythonã€Goã€Javaã€Node.js ç¤ºä¾‹
5. **é«˜çº§ç‰¹æ€§**ï¼šé™çº§ç­–ç•¥ã€è¿æ¥æ± ã€æ‰¹é‡å¤„ç†ã€å¼‚æ­¥è°ƒç”¨
6. **é”™è¯¯å¤„ç†**ï¼šå¸¸è§é”™è¯¯ç±»å‹å’Œé‡è¯•ç­–ç•¥
7. **æ€§èƒ½ä¼˜åŒ–**ï¼šè¿æ¥å¤ç”¨ã€æ‰¹é‡å¤„ç†ã€ç¼“å­˜
8. **æ•…éšœæ’æŸ¥**ï¼š6 å¤§å¸¸è§é—®é¢˜çš„æ’æŸ¥å’Œè§£å†³æ–¹æ¡ˆ
9. **FAQ**ï¼š8 ä¸ªå¸¸è§é—®é¢˜çš„è¯¦ç»†è§£ç­”

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- âœ… æœåŠ¡ç«¯åªè´Ÿè´£è§£æäºŒè¿›åˆ¶å†…å®¹ï¼ˆå•ä¸€èŒè´£ï¼‰
- âœ… å®¢æˆ·ç«¯è´Ÿè´£æ–‡ä»¶è¯»å–å’Œè¿æ¥ç®¡ç†
- âœ… é™çº§ç­–ç•¥åº”åœ¨è°ƒç”¨æ–¹å®ç°ï¼ˆè€ŒéæœåŠ¡ç«¯ï¼‰
- âœ… ä½¿ç”¨è¿æ¥æ± å’Œæ‰¹é‡å¤„ç†æå‡æ€§èƒ½
- âœ… å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•ç­–ç•¥

**è·å–å¸®åŠ©**ï¼š
- ğŸ“§ æŠ€æœ¯æ”¯æŒï¼šè¯·è”ç³»æœåŠ¡ç«¯ç»´æŠ¤å›¢é˜Ÿ
- ğŸ“– Proto æ–‡ä»¶ï¼šä»æœåŠ¡ç«¯é¡¹ç›®è·å– `grpc/protos/parser.proto`
- ğŸ› é—®é¢˜åé¦ˆï¼šé€šè¿‡ issue tracker æäº¤

---

**æœ€åæ›´æ–°**ï¼š2025-11-14
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0
